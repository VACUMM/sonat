# Fortran interface to some of the SANGOMA library (http://www.data-assimilation.net/) routines

SUBROUTINE f_arm( &
  nstate, nens, nobs, ndof, Af, Yf, R, arm_spect, arm, arm_rep, status &
  )
! AUTHOR
! Pierre De Mey

! REVISION HISTORY
! 2011-06: P De Mey arm.f Bologna Summer School 2011
! 2013-06: P De Mey arm.f Bologna Summer School 2013
! 2014-03: P De Mey sangoma_arm.F90 initial SANGOMA release
! 2015-10: P De Mey sangoma_arm.F90 adjusted some comments,
!          changed name of variable Df to Yf

! PURPOSE
! Calculate array modes and associated quantities

! INPUT
! nstate    state size
! nens      Ensemble size
! nobs      number of observations
! ndof      =MIN(nens,nobs) number of d.o.f.s of problem
! Af        forecast ensemble anomalies, defined as Af(nstate,nens)
! Yf        same as Af in data space, defined as Yf(nobs,nens)
!       note: Yf can be directly generated by the model, or
!       linearly calculated as H*Af, H(nobs,nstate) = obs.op.
! R     observation error covariance matrix, def as R(nobs,nobs)

! OUTPUT
! arm_spect array mode spectrum, defined as arm_spect(ndof)
! arm       array modes, defined as arm(nobs,ndof)
! arm_rep   modal representers, defined as arm_rep(nstate,ndof)
! status    status flag (0=success)

! NOTES
! 1. The actual precision of REAL is to be provided by the compiler.  Only
!    KIND=8 will work with the current version (promotion of REAL to DOUBLE
!    PRECISION) because of the use of Dxxxxx BLAS/LAPACK calls.  This can
!    be changed in a later version.
! 2. State space and data space are n-dimensional + (optionally) time.
!    - Each state-space sample and data-space sample can contain
!      information from several instants if desired.
!    - Modal representers can span space *and* time.


  IMPLICIT NONE

! args

  INTEGER(4), INTENT(in)  :: nstate
  INTEGER(4), INTENT(in)  :: nens
  INTEGER(4), INTENT(in)  :: nobs
  INTEGER(4), INTENT(in)  :: ndof
  REAL(8), INTENT(in)    :: Af(nstate,nens)
  REAL(8), INTENT(in)    :: Yf(nobs,nens)
  REAL(8), INTENT(in)    :: R(nobs,nobs)
  REAL(8), INTENT(out)   :: arm_spect(ndof)
  REAL(8), INTENT(out)   :: arm(nobs,ndof)
  REAL(8), INTENT(out)   :: arm_rep(nstate,ndof)
  INTEGER(4), INTENT(out) :: status

    call sangoma_arm(nstate, nens, nobs, ndof, Af, Yf, R, arm_spect, arm, arm_rep, status &
  )

    end SUBROUTINE f_arm



SUBROUTINE f_sampleens(dim, dim_ens, modes, svals, state, &
     ens, flag)

! !DESCRIPTION:
! This routine generates an ensemble of model states from a provided
! mean state and EOF modes (singular vectors of a peturbation matrix)
! and singular values. The resulting ensemble is the 2nd order-exact
! sample covariance matrix and mean state.
! the ensemble state vectors are computed as
!   $ens_i = state + sqrt(dim_ens-1) modes (\Omega C)^T$
! where $C$ holds in its diagonal the singular values ($svals$). $\Omega$
! is an orthogonal transformation matrix that preserves the mean state.
! The generated ensemble fulfills the condition for the state error
! covariance matrix
!   $P = 1/(sqrt(dim_ens-1)  \sum_{i=1}^{dim\_ens} (ens_i - state)(ens_i - state)^T$
!
! !REVISION HISTORY:
! 2014-05 - Lars Nerger - Initial code based on PDAF example code.
!
! !USES:

  IMPLICIT NONE

! !ARGUMENTS:
  INTEGER(4), INTENT(in) :: dim                    ! Size of state vector
  INTEGER(4), INTENT(in) :: dim_ens                ! Size of ensemble
  REAL(8), INTENT(inout) :: modes(dim, dim_ens-1) ! Array of EOF modes
  REAL(8), INTENT(in)    :: svals(dim_ens-1)      ! Vector of singular values
  REAL(8), INTENT(inout) :: state(dim)            ! PE-local model state
  REAL(8), INTENT(out)   :: ens(dim, dim_ens)     ! State ensemble
  INTEGER(4), INTENT(inout) :: flag                ! Status flag

    call  sangoma_SampleEns(dim, dim_ens, modes, svals, state, &
     ens, flag)

end SUBROUTINE f_sampleens


!    SUBROUTINE PDAF_seik_omega(rank, omega, omegatype, screen)
!
! ! !DESCRIPTION:
! ! Generate a transformation matrix OMEGA for
! ! the generation and transformation of the
! ! ensemble in the SEIK and LSEIK filter.
! ! Generated is a uniform orthogonal matrix OMEGA
! ! with R columns orthonormal in $R^{r+1}$
! ! and orthogonal to (1,...,1)' by iteratively
! ! applying the Householder matrix onto random
! ! vectors distributed uniformly on the unit sphere.
! !
! ! This version initializes at each iteration step
! ! the whole Householder matrix and subsequently
! ! computes Omega using GEMM from BLAS. All fields are
! ! allocated once at their maximum required size.
! ! (On SGI O2K this is about a factor of 2.5 faster
! ! than the version applying BLAS DDOT, but requires
! ! more memory.)
! !
! ! For omegatype=0 a deterministic omega is computed
! ! where the Housholder matrix of (1,...,1)' is operated
! ! on an identity matrix.
! !
! ! !  This is a core routine of PDAF and
! !    should not be changed by the user   !
! !
! ! !REVISION HISTORY:
! ! 2002-01 - Lars Nerger - Initial code
! ! 2014-05 - Lars Nerger - simplified version for SANGOMA
! !
! ! !USES:
!   IMPLICIT NONE
!
! ! !ARGUMENTS:
!   INTEGER, INTENT(in) :: rank      ! Approximated rank of covar matrix
!   REAL(8), INTENT(inout) :: omega(rank+1, rank) ! Matrix Omega
!   INTEGER, INTENT(in) :: omegatype ! Select type of omega:
!                                    !   (1) generated from random vectors
!                                    !   (0) generated from deterministic vectors
!                                    ! (other) product of matrix from (2) with
!                                    !      orthonormal random matrix orthogonal (1....1)T
!   INTEGER, INTENT(in) :: screen    ! Verbosity flag
!
! call PDAF_seik_omega(rank, omega, omegatype, screen)
! end  SUBROUTINE PDAF_seik_omega


SUBROUTINE f_eofcovar(dim_state, nstates, nfields, dim_fields, offsets, &
     remove_mstate, do_mv, states, stddev, svals, svec, meanstate, status)

! !DESCRIPTION:
! This routine performs an EOF analysis by singular value decomposition. It is
! used to prepare a covariance matrix for initializing an ensemble.  For
! the decomposition a multivariate scaling can be performed by
! 'sangoma\_MVNormalize' to ensure that all fields in the state vectors have
! unit variance.
!
! To use this routine, one has to initialize the array 'states' holding in
! each column a perturbation vector (state - mean) from a state trajectory.
! Outputs are the arrays of singular values (svals) and left singular vectors
! (svec). The singular values are scaled by sqrt(1/(nstates-1)). With this,
! $svec * svals^2 * svec^T$ is the covariance matrix. In addition, the standard
! deviation of the field variations (stddev) is an output array.
! To use the multivariate normalization one has to define the number of
! different fields in the state (nfields), the dimension of each fields and
! the offset of field from the start of each state vector.
!
! The routine uses the LAPACK routine 'dgesvd' to compute the singular value
! decomposition.
!
! !REVISION HISTORY:
! 2012-09 - Lars Nerger - Initial code for SANGOMA based on PDAF
! 2013-11 - L. Nerger - Adaption to SANGOMA data model
!
! !USES:
  IMPLICIT NONE

! !ARGUMENTS:
  INTEGER(4), INTENT(in) :: dim_state           ! Dimension of state vector
  INTEGER(4), INTENT(in) :: nstates             ! Number of state vectors
  INTEGER(4), INTENT(in) :: nfields             ! Number of fields in state vector
  INTEGER(4), INTENT(in) :: dim_fields(nfields) ! Size of each field
  INTEGER(4), INTENT(in) :: offsets(nfields)    ! Start position of each field
  INTEGER(4), INTENT(in) :: do_mv               ! 1: Do multivariate scaling
     ! nfields, dim_fields and offsets are only used if do_mv=1
  INTEGER(4), INTENT(in) :: remove_mstate       ! 1: subtract mean state from states
     ! before computing EOFs
  REAL(8), INTENT(inout)  :: states(dim_state, nstates) ! State perturbations
  REAL(8), INTENT(out) :: stddev(nfields)      ! Standard deviation of field variability
     ! Without multivariate scaling (do_mv=0), it is stddev = 1.0
  REAL(8), INTENT(out) :: svals(nstates)       ! Singular values divided by sqrt(nstates-1)
  REAL(8), INTENT(out) :: svec(dim_state, nstates)   ! Singular vectors
  REAL(8), INTENT(inout) :: meanstate(dim_state)     ! Mean state (only changed if remove_mstate=1)
  INTEGER(4), INTENT(out) :: status             ! Status flag

call sangoma_eofcovar(dim_state, nstates, nfields, dim_fields, offsets, &
     remove_mstate, do_mv, states, stddev, svals, svec, meanstate, status)
     
end SUBROUTINE f_eofcovar


SUBROUTINE f_computeensstats(dim, dim_ens, element, &
     state, ens, skewness, kurtosis, status)
    ! !DESCRIPTION:
    ! This routine computes the higher-order ensemble statistics (skewness and
    ! kurtosis). Inputes are the ensemble array and the state vector about which
    ! the histogram is computed (usually the ensemble mean). In addition, the
    ! index of the element has to be specified for which the statistics are
    ! computed. If this is 0, the mean statistics over all elements are computed.
    !
    ! The definition used for kurtosis follows that used by Lawson and Hansen,
    ! Mon. Wea. Rev. 132 (2004) 1966.
    !
    ! !REVISION HISTORY:
    ! 2012-09 - Lars Nerger - Initial code for SANGOMA based on PDAF
    ! 2013-11 - L. Nerger - Adaption to SANGOMA data model

    IMPLICIT NONE

    ! !ARGUMENTS:
    INTEGER(4), INTENT(in) :: dim               ! PE-local state dimension
    INTEGER(4), INTENT(in) :: dim_ens           ! Ensemble size
    INTEGER(4), INTENT(in) :: element           ! ID of element to be used
       ! If element=0, mean values over all elements are computed
    REAL(8), INTENT(in)    :: state(dim)        ! State vector
    REAL(8), INTENT(in)    :: ens(dim, dim_ens) ! State ensemble
    REAL(8), INTENT(out)   :: skewness          ! Skewness of ensemble
    REAL(8), INTENT(out)   :: kurtosis          ! Kurtosis of ensemble
    INTEGER(4), INTENT(out) :: status            ! Status flag (0=success)


    call  sangoma_computeensstats(dim, dim_ens, element, &
        & state, ens, skewness, kurtosis, status)

end SUBROUTINE f_computeensstats